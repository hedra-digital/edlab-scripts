#!/usr/bin/env python3

import argparse
import subprocess
import os
import logging
from PyPDF2 import PdfReader, PdfWriter
from pdf2image import convert_from_path

# Configuração do logging para depuração
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def delete_text_from_pdf(input_pdf, output_pdf):
    """Remove o texto de um PDF mantendo as imagens usando Ghostscript."""
    gs_command = [
        "gs",
        "-sDEVICE=pdfwrite",
        "-dFILTERTEXT",
        "-o", output_pdf,
        "-f", input_pdf
    ]

    logging.info(f"Executando o comando Ghostscript para remover texto: {' '.join(gs_command)}")

    # Executa o comando Ghostscript
    try:
        subprocess.run(gs_command, check=True)
        logging.info(f"PDF sem texto gerado com sucesso: {output_pdf}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Erro ao executar Ghostscript: {e}")

def crop_pdf_with_pdfcrop(input_pdf, output_pdf, margins):
    """Usa pdfcrop para cortar as margens do PDF."""
    pdfcrop_command = ['pdfcrop', '--margins', margins, input_pdf, output_pdf]

    logging.info(f"Executando pdfcrop para cortar o PDF: {' '.join(pdfcrop_command)}")

    try:
        subprocess.run(pdfcrop_command, check=True)
        logging.info(f"PDF cortado com sucesso: {output_pdf}")
    except subprocess.CalledProcessError as e:
        logging.error(f"Erro ao executar pdfcrop: {e}")

def convert_pdf_to_images(input_pdf, output_dir, format='jpeg', page_range=None):
    """Converte páginas específicas de um PDF em imagens no formato especificado e salva no diretório."""
    logging.info(f"Convertendo {input_pdf} para imagens {format} no diretório {output_dir}")

    # Converte o PDF em imagens
    try:
        if page_range:
            images = convert_from_path(input_pdf, first_page=page_range[0], last_page=page_range[1])
        else:
            images = convert_from_path(input_pdf)

        image_paths = []
        num_pages = len(images)
        num_digits = len(str(num_pages))  # Exemplo: para 100 páginas, precisamos de 3 dígitos

        # Garante que o diretório de saída existe
        if not os.path.exists(output_dir):
            os.makedirs(output_dir)
            logging.info(f"Diretório criado: {output_dir}")

        for i, image in enumerate(images):
            # Formata o número da página com zeros à esquerda
            page_num_str = str(i + 1).zfill(num_digits)
            image_path = os.path.join(output_dir, f'page_{page_num_str}.{format}')
            image.save(image_path, format.upper())
            image_paths.append(image_path)
            logging.info(f"Página {i+1} salva como imagem: {image_path}")

        logging.info(f"Todas as páginas foram convertidas e salvas no diretório {output_dir}")
        return image_paths
    except Exception as e:
        logging.error(f"Erro ao converter PDF para imagens: {e}")
        return []

def extract_pages(input_pdf, output_pdf, page_range):
    """Extrai páginas específicas de um PDF e salva em um novo arquivo."""
    reader = PdfReader(input_pdf)
    writer = PdfWriter()

    for page_num in range(page_range[0] - 1, page_range[1]):
        writer.add_page(reader.pages[page_num])

    with open(output_pdf, 'wb') as output_file:
        writer.write(output_file)

    logging.info(f"Páginas {page_range[0]}-{page_range[1]} extraídas com sucesso para {output_pdf}")

def parse_page_range(pages):
    """Interpreta a opção de intervalo de páginas e retorna a primeira e última página."""
    if '-' in pages:
        first_page, last_page = map(int, pages.split('-'))
        return first_page, last_page
    else:
        page = int(pages)
        return page, page

def rename_file(old_name, new_name):
    """Renomeia um arquivo."""
    try:
        os.rename(old_name, new_name)
        logging.info(f"Arquivo renomeado de {old_name} para {new_name}")
    except OSError as e:
        logging.error(f"Erro ao renomear arquivo: {e}")

def copy_file(source, destination):
    """Copia um arquivo mantendo o original."""
    try:
        import shutil
        shutil.copy2(source, destination)
        logging.info(f"Arquivo copiado de {source} para {destination}")
    except OSError as e:
        logging.error(f"Erro ao copiar arquivo: {e}")

def generate_output_filename(input_path, suffix=""):
    """
    Gera um nome de arquivo de saída baseado no arquivo de entrada.
    Adiciona um sufixo antes da extensão se fornecido.
    
    Args:
        input_path: Caminho do arquivo de entrada
        suffix: Sufixo a ser adicionado antes da extensão
    """
    directory = os.path.dirname(input_path)
    filename = os.path.basename(input_path)
    name, ext = os.path.splitext(filename)
    
    if suffix:
        new_name = f"{name}_{suffix}{ext}"
    else:
        new_name = f"{name}_modified{ext}"
    
    # Se o diretório estiver vazio, usa o diretório atual
    if directory:
        return os.path.join(directory, new_name)
    return new_name
def find_pdf_files(input_paths):
    """
    Encontra arquivos PDF baseado nos caminhos de entrada.
    Suporta arquivo único, wildcards e diretórios.
    
    Args:
        input_paths: Lista de caminhos ou padrões
        
    Returns:
        Lista de caminhos de arquivos PDF encontrados
    """
    import glob
    
    pdf_files = []
    
    for input_path in input_paths:
        if os.path.isdir(input_path):
            # Se for um diretório, procura todos os PDFs nele
            pdf_files.extend(sorted(glob.glob(os.path.join(input_path, "*.pdf"))))
        elif '*' in input_path:
            # Se contiver wildcard, usa glob diretamente
            pdf_files.extend(sorted(glob.glob(input_path)))
        elif os.path.isfile(input_path):
            # Se for um arquivo único, adiciona se for PDF
            if input_path.lower().endswith('.pdf'):
                pdf_files.append(input_path)
    
    # Remove duplicatas mantendo a ordem
    return list(dict.fromkeys(pdf_files))

def merge_pdfs(input_files, output_file):
    """
    Junta múltiplos arquivos PDF em um único arquivo.
    
    Args:
        input_files: Lista de caminhos dos arquivos PDF a serem unidos
        output_file: Caminho do arquivo PDF de saída
    """
    merger = PdfWriter()
    
    try:
        # Verifica se todos os arquivos existem e são PDFs
        for pdf_file in input_files:
            if not os.path.exists(pdf_file):
                raise FileNotFoundError(f"Arquivo não encontrado: {pdf_file}")
            if not pdf_file.lower().endswith('.pdf'):
                raise ValueError(f"Arquivo não é um PDF: {pdf_file}")
        
        # Adiciona cada PDF ao merger
        for pdf_file in input_files:
            logging.info(f"Adicionando arquivo: {pdf_file}")
            reader = PdfReader(pdf_file)
            merger.append(reader)
        
        # Salva o PDF unificado
        with open(output_file, 'wb') as output:
            merger.write(output)
        
        logging.info(f"PDFs unidos com sucesso em: {output_file}")
        return True
        
    except Exception as e:
        logging.error(f"Erro ao unir PDFs: {str(e)}")
        return False

def main():
    parser = argparse.ArgumentParser(description="Manipulação de arquivos PDF: juntar, remover texto, cortar margens, extrair páginas e converter para imagens.")
    
    parser.add_argument("-i", "--input", required=True, nargs='+',
                       help="Arquivo(s) PDF de entrada. Pode ser:\n" +
                            "- Um ou mais arquivos (ex: file1.pdf file2.pdf)\n" +
                            "- Um padrão com wildcard (ex: *.pdf)\n" +
                            "- Um diretório (ex: ./pdfs)")
    parser.add_argument("-o", "--output", 
                       help="Arquivo de saída para operações em arquivo único ou junção, ou diretório para múltiplos arquivos.")
    parser.add_argument("-m", "--margins", 
                       help="Margens para o corte com pdfcrop. Use um valor ou quatro valores para margens separadas.")
    parser.add_argument("-d", "--dir", 
                       help="Diretório onde as imagens serão salvas.")
    parser.add_argument("-p", "--pages", 
                       help="Intervalo de páginas para processar (ex: '1-3' ou '1').")
    parser.add_argument("-f", "--format", default="jpeg",
                       help="Formato da imagem de saída (jpeg ou png). Padrão: jpeg.")
    parser.add_argument("-rt", "--remove-text", action='store_true',
                       help="Remove o texto do PDF antes de cortar margens e converter em imagens.")
    parser.add_argument("-j", "--join", action='store_true',
                       help="Junta múltiplos PDFs em um único arquivo.")

    args = parser.parse_args()

    try:
        # Encontra todos os arquivos PDF baseado nos inputs
        input_files = find_pdf_files(args.input)
        
        if not input_files:
            logging.error("Nenhum arquivo PDF encontrado nos caminhos especificados")
            return

        logging.info(f"Encontrados {len(input_files)} arquivos PDF para processar:")
        for file in input_files:
            logging.info(f"- {file}")

        # Se a opção de juntar PDFs foi selecionada
        if args.join:
            if len(input_files) < 2:
                logging.error("São necessários pelo menos 2 arquivos PDF para juntar")
                return
                
            # Define o arquivo de saída para os PDFs unidos
            if args.output:
                output_file = args.output if args.output.lower().endswith('.pdf') else args.output + '.pdf'
            else:
                # Se não especificado, usa o primeiro arquivo como base para o nome
                output_file = generate_output_filename(input_files[0], "merged")
            
            # Junta os PDFs
            if merge_pdfs(input_files, output_file):
                logging.info("Operação de junção concluída com sucesso")
            else:
                logging.error("Falha na operação de junção")
            return

        # Se não for junção, processa um único arquivo
        if len(input_files) > 1:
            logging.error("Múltiplos arquivos de entrada só são permitidos com a opção --join")
            return
            
        input_file = input_files[0]
        
        # Gera nome do arquivo de saída se não especificado
        if not args.output:
            suffix = []
            if args.pages:
                suffix.append(f"pages_{args.pages.replace('-', 'to')}")
            if args.remove_text:
                suffix.append("notext")
            if args.margins:
                suffix.append("cropped")
            
            suffix_str = "_".join(suffix) if suffix else ""
            args.output = generate_output_filename(input_file, suffix_str)
            logging.info(f"Nome do arquivo de saída gerado automaticamente: {args.output}")

        page_range = None
        if args.pages:
            page_range = parse_page_range(args.pages)

        # Resto do processamento para arquivo único
        temp_pdf = "temp_extracted.pdf"
        if page_range:
            extract_pages(input_file, temp_pdf, page_range)
            input_pdf = temp_pdf
        else:
            input_pdf = input_file

        if args.remove_text:
            delete_text_from_pdf(input_pdf, args.output)
        else:
            copy_file(input_pdf, args.output)

        if args.margins:
            cropped_output = args.output.replace(".pdf", "_cropped.pdf")
            crop_pdf_with_pdfcrop(args.output, cropped_output, args.margins)
            os.remove(args.output)
            rename_file(cropped_output, args.output)

        if page_range and os.path.exists(temp_pdf):
            os.remove(temp_pdf)

        if args.dir:
            convert_pdf_to_images(args.output, args.dir, args.format.lower(), page_range)

    except Exception as e:
        logging.error(f"Erro durante o processamento: {str(e)}")
        raise

if __name__ == "__main__":
    main()