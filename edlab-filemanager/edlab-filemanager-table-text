#!/usr/bin/env python3

import os
import re
import argparse
from pathlib import Path
from colorama import Fore, Style, init

# Inicializa o colorama
init(autoreset=True)

# Função para renomear um arquivo aplicando uma tabela de mapeamento
def rename_with_table(filepath, mapping, dry_run, prefix_str=""):
    original_filename = filepath.name
    if original_filename in mapping:
        new_filename = mapping[original_filename]
        output = f"{prefix_str}{Fore.RED}{original_filename} -> {Fore.GREEN}{new_filename}"
        if dry_run:
            print(output)
        else:
            new_path = filepath.with_name(new_filename)
            filepath.rename(new_path)
            print(output)
        return output
    else:
        return f"{prefix_str}{Fore.YELLOW}{original_filename} (no change)"

# Função para carregar a tabela de renomeação
def load_rename_table(table_path):
    mapping = {}
    with open(table_path, 'r') as table_file:
        for line in table_file:
            parts = line.strip().split()
            if len(parts) == 2:
                old_name, new_name = parts
                mapping[old_name] = new_name
    return mapping

# Função para exibir a árvore de diretórios e processar os arquivos com base na tabela
def process_tree_with_table(directory, mapping, dry_run, prefix=None, suffix=None):
    output = []
    
    def print_tree(root, prefix_str=""):
        contents = list(Path(root).iterdir())
        pointers = ['├── '] * (len(contents) - 1) + ['└── ']

        for pointer, path in zip(pointers, contents):
            if path.is_dir():
                output.append(f"{prefix_str}{pointer}{path.name}/")
                print_tree(path, prefix_str + "    " if pointer == '└── ' else prefix_str + "│   ")
            else:
                filename = path.name
                if (prefix and not filename.startswith(prefix)) or (suffix and not filename.endswith(suffix)):
                    continue  # Filtra arquivos que não seguem o padrão de prefixo ou sufixo
                result = rename_with_table(path, mapping, dry_run, prefix_str + pointer)
                if result:
                    output.append(result)
    
    print_tree(directory)
    return "\n".join(output)

# Função principal
def main():
    parser = argparse.ArgumentParser(description="File manager to rename files based on a table or align numerical place values.")
    parser.add_argument("paths", nargs="+", help="File(s) or directory to process.")
    parser.add_argument("--tree", action="store_true", help="Process directories recursively.")
    parser.add_argument("--align-place-values", "-pva", action="store_true", help="Align numerical place values in filenames.")
    parser.add_argument("--table-name", "-tn", type=str, help="File containing a table of old and new filenames.")
    parser.add_argument("--prefix-pattern", "-pp", type=str, help="Only process files that start with this prefix.")
    parser.add_argument("--suffix-pattern", "-sp", type=str, help="Only process files that end with this suffix.")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be done, without making any changes.")
    
    args = parser.parse_args()

    target_paths = [Path(path) for path in args.paths]

    # Verifica a existência dos arquivos/diretórios fornecidos
    for target_path in target_paths:
        if not target_path.exists():
            print(f"Error: '{target_path}' does not exist.")
            return

    # Se a opção de tabela for fornecida, carregamos a tabela de renomeação
    mapping = {}
    if args.table_name:
        mapping = load_rename_table(args.table_name)
        print(f"Loaded renaming table from {args.table_name}")

    # Processa usando a tabela de renomeação se fornecida
    if args.table_name:
        for target_path in target_paths:
            if target_path.is_dir():
                print(f"Processing directory: {target_path}")
                tree_output = process_tree_with_table(target_path, mapping, args.dry_run, prefix=args.prefix_pattern, suffix=args.suffix_pattern)
                print(tree_output)
            elif target_path.is_file():
                # Se for um arquivo único, aplica o mapeamento
                rename_with_table(target_path, mapping, args.dry_run)
        return

    # Caso contrário, use o processo de alinhamento de casas numéricas (não modificado)
    if args.align_place_values:
        # Adicionar código aqui para alinhamento de casas numéricas
        pass

if __name__ == "__main__":
    main()
